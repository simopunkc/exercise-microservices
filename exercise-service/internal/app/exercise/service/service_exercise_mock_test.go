// Code generated by moq; DO NOT EDIT.
// github.com/matryer/moq

package service

import (
	"exercise-service/internal/app/domain"
	"sync"
)

// Ensure, that RepositoryExerciseMock does implement RepositoryExercise.
// If this is not the case, regenerate this file with moq.
var _ RepositoryExercise = &RepositoryExerciseMock{}

// RepositoryExerciseMock is a mock implementation of RepositoryExercise.
//
// 	func TestSomethingThatUsesRepositoryExercise(t *testing.T) {
//
// 		// make and configure a mocked RepositoryExercise
// 		mockedRepositoryExercise := &RepositoryExerciseMock{
// 			CreateAnswerFunc: func(answer domain.Answer) domain.Repository {
// 				panic("mock out the CreateAnswer method")
// 			},
// 			CreateExerciseFunc: func(exercise domain.Exercise) domain.Repository {
// 				panic("mock out the CreateExercise method")
// 			},
// 			CreateQuestionFunc: func(question domain.Question) domain.Repository {
// 				panic("mock out the CreateQuestion method")
// 			},
// 			GetAnswerByUserIDFunc: func(userID int64) domain.Repository {
// 				panic("mock out the GetAnswerByUserID method")
// 			},
// 			GetExerciseByIDFunc: func(id int64) domain.Repository {
// 				panic("mock out the GetExerciseByID method")
// 			},
// 			GetPublicExerciseByIDFunc: func(id int64) domain.Repository {
// 				panic("mock out the GetPublicExerciseByID method")
// 			},
// 		}
//
// 		// use mockedRepositoryExercise in code that requires RepositoryExercise
// 		// and then make assertions.
//
// 	}
type RepositoryExerciseMock struct {
	// CreateAnswerFunc mocks the CreateAnswer method.
	CreateAnswerFunc func(answer domain.Answer) domain.Repository

	// CreateExerciseFunc mocks the CreateExercise method.
	CreateExerciseFunc func(exercise domain.Exercise) domain.Repository

	// CreateQuestionFunc mocks the CreateQuestion method.
	CreateQuestionFunc func(question domain.Question) domain.Repository

	// GetAnswerByUserIDFunc mocks the GetAnswerByUserID method.
	GetAnswerByUserIDFunc func(userID int64) domain.Repository

	// GetExerciseByIDFunc mocks the GetExerciseByID method.
	GetExerciseByIDFunc func(id int64) domain.Repository

	// GetPublicExerciseByIDFunc mocks the GetPublicExerciseByID method.
	GetPublicExerciseByIDFunc func(id int64) domain.Repository

	// calls tracks calls to the methods.
	calls struct {
		// CreateAnswer holds details about calls to the CreateAnswer method.
		CreateAnswer []struct {
			// Answer is the answer argument value.
			Answer domain.Answer
		}
		// CreateExercise holds details about calls to the CreateExercise method.
		CreateExercise []struct {
			// Exercise is the exercise argument value.
			Exercise domain.Exercise
		}
		// CreateQuestion holds details about calls to the CreateQuestion method.
		CreateQuestion []struct {
			// Question is the question argument value.
			Question domain.Question
		}
		// GetAnswerByUserID holds details about calls to the GetAnswerByUserID method.
		GetAnswerByUserID []struct {
			// UserID is the userID argument value.
			UserID int64
		}
		// GetExerciseByID holds details about calls to the GetExerciseByID method.
		GetExerciseByID []struct {
			// ID is the id argument value.
			ID int64
		}
		// GetPublicExerciseByID holds details about calls to the GetPublicExerciseByID method.
		GetPublicExerciseByID []struct {
			// ID is the id argument value.
			ID int64
		}
	}
	lockCreateAnswer          sync.RWMutex
	lockCreateExercise        sync.RWMutex
	lockCreateQuestion        sync.RWMutex
	lockGetAnswerByUserID     sync.RWMutex
	lockGetExerciseByID       sync.RWMutex
	lockGetPublicExerciseByID sync.RWMutex
}

// CreateAnswer calls CreateAnswerFunc.
func (mock *RepositoryExerciseMock) CreateAnswer(answer domain.Answer) domain.Repository {
	if mock.CreateAnswerFunc == nil {
		panic("RepositoryExerciseMock.CreateAnswerFunc: method is nil but RepositoryExercise.CreateAnswer was just called")
	}
	callInfo := struct {
		Answer domain.Answer
	}{
		Answer: answer,
	}
	mock.lockCreateAnswer.Lock()
	mock.calls.CreateAnswer = append(mock.calls.CreateAnswer, callInfo)
	mock.lockCreateAnswer.Unlock()
	return mock.CreateAnswerFunc(answer)
}

// CreateAnswerCalls gets all the calls that were made to CreateAnswer.
// Check the length with:
//     len(mockedRepositoryExercise.CreateAnswerCalls())
func (mock *RepositoryExerciseMock) CreateAnswerCalls() []struct {
	Answer domain.Answer
} {
	var calls []struct {
		Answer domain.Answer
	}
	mock.lockCreateAnswer.RLock()
	calls = mock.calls.CreateAnswer
	mock.lockCreateAnswer.RUnlock()
	return calls
}

// CreateExercise calls CreateExerciseFunc.
func (mock *RepositoryExerciseMock) CreateExercise(exercise domain.Exercise) domain.Repository {
	if mock.CreateExerciseFunc == nil {
		panic("RepositoryExerciseMock.CreateExerciseFunc: method is nil but RepositoryExercise.CreateExercise was just called")
	}
	callInfo := struct {
		Exercise domain.Exercise
	}{
		Exercise: exercise,
	}
	mock.lockCreateExercise.Lock()
	mock.calls.CreateExercise = append(mock.calls.CreateExercise, callInfo)
	mock.lockCreateExercise.Unlock()
	return mock.CreateExerciseFunc(exercise)
}

// CreateExerciseCalls gets all the calls that were made to CreateExercise.
// Check the length with:
//     len(mockedRepositoryExercise.CreateExerciseCalls())
func (mock *RepositoryExerciseMock) CreateExerciseCalls() []struct {
	Exercise domain.Exercise
} {
	var calls []struct {
		Exercise domain.Exercise
	}
	mock.lockCreateExercise.RLock()
	calls = mock.calls.CreateExercise
	mock.lockCreateExercise.RUnlock()
	return calls
}

// CreateQuestion calls CreateQuestionFunc.
func (mock *RepositoryExerciseMock) CreateQuestion(question domain.Question) domain.Repository {
	if mock.CreateQuestionFunc == nil {
		panic("RepositoryExerciseMock.CreateQuestionFunc: method is nil but RepositoryExercise.CreateQuestion was just called")
	}
	callInfo := struct {
		Question domain.Question
	}{
		Question: question,
	}
	mock.lockCreateQuestion.Lock()
	mock.calls.CreateQuestion = append(mock.calls.CreateQuestion, callInfo)
	mock.lockCreateQuestion.Unlock()
	return mock.CreateQuestionFunc(question)
}

// CreateQuestionCalls gets all the calls that were made to CreateQuestion.
// Check the length with:
//     len(mockedRepositoryExercise.CreateQuestionCalls())
func (mock *RepositoryExerciseMock) CreateQuestionCalls() []struct {
	Question domain.Question
} {
	var calls []struct {
		Question domain.Question
	}
	mock.lockCreateQuestion.RLock()
	calls = mock.calls.CreateQuestion
	mock.lockCreateQuestion.RUnlock()
	return calls
}

// GetAnswerByUserID calls GetAnswerByUserIDFunc.
func (mock *RepositoryExerciseMock) GetAnswerByUserID(userID int64) domain.Repository {
	if mock.GetAnswerByUserIDFunc == nil {
		panic("RepositoryExerciseMock.GetAnswerByUserIDFunc: method is nil but RepositoryExercise.GetAnswerByUserID was just called")
	}
	callInfo := struct {
		UserID int64
	}{
		UserID: userID,
	}
	mock.lockGetAnswerByUserID.Lock()
	mock.calls.GetAnswerByUserID = append(mock.calls.GetAnswerByUserID, callInfo)
	mock.lockGetAnswerByUserID.Unlock()
	return mock.GetAnswerByUserIDFunc(userID)
}

// GetAnswerByUserIDCalls gets all the calls that were made to GetAnswerByUserID.
// Check the length with:
//     len(mockedRepositoryExercise.GetAnswerByUserIDCalls())
func (mock *RepositoryExerciseMock) GetAnswerByUserIDCalls() []struct {
	UserID int64
} {
	var calls []struct {
		UserID int64
	}
	mock.lockGetAnswerByUserID.RLock()
	calls = mock.calls.GetAnswerByUserID
	mock.lockGetAnswerByUserID.RUnlock()
	return calls
}

// GetExerciseByID calls GetExerciseByIDFunc.
func (mock *RepositoryExerciseMock) GetExerciseByID(id int64) domain.Repository {
	if mock.GetExerciseByIDFunc == nil {
		panic("RepositoryExerciseMock.GetExerciseByIDFunc: method is nil but RepositoryExercise.GetExerciseByID was just called")
	}
	callInfo := struct {
		ID int64
	}{
		ID: id,
	}
	mock.lockGetExerciseByID.Lock()
	mock.calls.GetExerciseByID = append(mock.calls.GetExerciseByID, callInfo)
	mock.lockGetExerciseByID.Unlock()
	return mock.GetExerciseByIDFunc(id)
}

// GetExerciseByIDCalls gets all the calls that were made to GetExerciseByID.
// Check the length with:
//     len(mockedRepositoryExercise.GetExerciseByIDCalls())
func (mock *RepositoryExerciseMock) GetExerciseByIDCalls() []struct {
	ID int64
} {
	var calls []struct {
		ID int64
	}
	mock.lockGetExerciseByID.RLock()
	calls = mock.calls.GetExerciseByID
	mock.lockGetExerciseByID.RUnlock()
	return calls
}

// GetPublicExerciseByID calls GetPublicExerciseByIDFunc.
func (mock *RepositoryExerciseMock) GetPublicExerciseByID(id int64) domain.Repository {
	if mock.GetPublicExerciseByIDFunc == nil {
		panic("RepositoryExerciseMock.GetPublicExerciseByIDFunc: method is nil but RepositoryExercise.GetPublicExerciseByID was just called")
	}
	callInfo := struct {
		ID int64
	}{
		ID: id,
	}
	mock.lockGetPublicExerciseByID.Lock()
	mock.calls.GetPublicExerciseByID = append(mock.calls.GetPublicExerciseByID, callInfo)
	mock.lockGetPublicExerciseByID.Unlock()
	return mock.GetPublicExerciseByIDFunc(id)
}

// GetPublicExerciseByIDCalls gets all the calls that were made to GetPublicExerciseByID.
// Check the length with:
//     len(mockedRepositoryExercise.GetPublicExerciseByIDCalls())
func (mock *RepositoryExerciseMock) GetPublicExerciseByIDCalls() []struct {
	ID int64
} {
	var calls []struct {
		ID int64
	}
	mock.lockGetPublicExerciseByID.RLock()
	calls = mock.calls.GetPublicExerciseByID
	mock.lockGetPublicExerciseByID.RUnlock()
	return calls
}
